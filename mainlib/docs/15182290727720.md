# <center>JAVA SE 基础总结（7-）
##Day7
1. 成员变量和局部变量的区别
	- 在类中的位置不同
		+ 成员变量：类中方法外
		+ 局部变量：方法定义中或者方法声明上
	- 在内存中的位置不同
		+ 成员变量：在堆中
		+ 局部变量：在栈中
	- 生命周期不同
		+ 成员变量：随着对象的创建而存在，随着对象的消失而消失
		+ 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失
	- 初始化值不同
		+ 成员变量：有默认值
		+ 局部变量：没有默认值，必须定义，赋值，然后才能使用
2. 匿名对象
	- 没有名字的对象
	- 应用场景
		+ 调用方法，仅仅只调用一次的时候。
		+ 可以作为实际参数传递。
		
3. 封装
	+ 隐藏实现细节，提供公共的访问方式
	+ 好处：
		- 隐藏实现细节，提供公共的访问方式
		- 提高代码的复用性
		- 提高代码的安全性
	+ 设计原则
		- 把不想让外界知道的实现细节给隐藏起来，提供公共的访问方式
	+ private是封装的一种体现。
		- 封装：类，方法，private修饰成员变量

4. 构造方法
	+ 构造方法中可不可以有return语句呢?
		- 可以。而是我们写成这个样子就OK了：return;
		- 其实，在任何的void类型的方法的最后你都可以写上：return;
	+ 推荐：永远手动自己给出无参构造方法。

5. static关键字
	+ 静态的意思。可以修饰成员变量和成员方法。
	+ 静态的特点：
		- 随着类的加载而加载
		- 优先与对象存在
		- 被类的所有对象共享
			* 这其实也是我们判断该不该使用静态的依据。
			* 举例：饮水机和水杯的问题思考
		- 可以通过类名调用
			* 既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。
	+ 静态的内存图
		- 静态的内容在方法区的静态区
	+ 静态的注意事项；
		- 在静态方法中没有this对象
		- 静态只能访问静态(代码测试过)
	+ 静态变量和成员变量的区别
		- 所属不同
			* 静态变量：属于类，类变量
			* 成员变量：属于对象，对象变量，实例变量
		- 内存位置不同
			* 静态变量：方法区的静态区
			* 成员变量：堆内存
		- 生命周期不同
			* 静态变量：静态变量是随着类的加载而加载，随着类的消失而消失
			* 成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失
		- 调用不同
			* 静态变量：可以通过对象名调用，也可以通过类名调用(非私有)
			* 成员变量：只能通过对象名调用(非私有)

##Day8
1. 如何制作帮助文档(了解)
	+ 写一个类
	+ 加入文档注释
	+ 通过javadoc工具生成即可
		 `javadoc -d 目录 -author -version ArrayTool.java`
2. Math类
	+ 是针对数学进行操作的类
	+ 没有构造方法，因为它的成员都是静态的
	+ 产生随机数
      `public static double random(): [0.0,1.0)`
	+ 如何产生一个1-100之间的随机数
		`int number = (int)(Math.random()*100)+1;`

3. 代码块
	+ 用{}括起来的代码。
	+ 分类：
		- 局部代码块
			* 用于限定变量的生命周期，及早释放，提高内存利用率。
		- 构造代码块
			* 把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。
		- 静态代码块
			* 对类的数据进行初始化，仅仅只执行一次。
	+ 静态代码块,构造代码块,构造方法的顺序问题?
		- 静态代码块 > 构造代码块 > 构造方法
	
	```Java
	/*
	代码块：在Java中，使用{}括起来的代码被称为代码块。
	根据其位置和声明的不同，可以分为
		>局部代码块:局部位置,用于限定变量的生命周期。
		>构造代码块:在类中的成员位置,用{}括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。
			作用：可以把多个构造方法中的共同代码放到一起，对对象进行初始化。
		静态代码块:在类中的成员位置,用{}括起来的代码,只不过它用static修饰了。
			作用：一般是对类进行初始化。
	面试题?
		静态代码块,构造代码块,构造方法的执行顺序?
		静态代码块 -- 构造代码块 -- 构造方法
		静态代码块：只执行一次
		构造代码块：每次调用构造方法都执行
*/
class Student {
	static {
		System.out.println("Student 静态代码块");
	}
	
	{
		System.out.println("Student 构造代码块");
	}
	
	public Student() {
		System.out.println("Student 构造方法");
	}
}
	//测试
	class StudentDemo {
	static {
		System.out.println("林青霞都60了，我很伤心");
	}
	
	public static void main(String[] args) {
		System.out.println("我是main方法");
		
		Student s1 = new Student();
		Student s2 = new Student();
		
	程序的执行结果：
	林青霞都60了，我很伤心
	我是main方法
	Student 静态代码块（只执行一次）
	Student 构造代码块（调用一次，执行一次）
	Student 构造方法（调用一次，执行一次）
	Student 构造代码块（只执行一次）
	Student 构造方法（调用一次，执行一次）
	}
	```
	
4. 继承
	+ Java中继承的特点
		 - Java中类只支持单继承
		 - Java中可以多层(重)继承(继承体系)
	+ 继承的注意事项：
		- 子类不能继承父类的私有成员
		- 子类不能继承父类的构造方法，但是可以通过super去访问
		- 不要为了部分功能而去继承
	+ 什么时候使用继承呢?
		- 继承体现的是：is a的关系。
		- 采用假设法
	+ Java继承中的成员关系
		- 子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?
			* 在子类方法的局部范围找，有就使用。
			* 在子类的成员范围找，有就使用。
			* 在父类的成员范围找，有就使用。
			* 找不到，就报错。
		- 构造方法
			* 子类的构造方法默认会去访问父类的无参构造方法
			  - 是为了子类访问父类数据的初始化
			  - 父类中如果没有无参构造方法，怎么办?
			  - 子类通过super去明确调用带参构造
			  - 子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造
				让父类提供无参构造
		- 成员方法
			+ 子类的成员方法和父类中的成员方法名称不一样，这个太简单
			+ 子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?
				- 通过子类对象访y问一个方法的查找顺序：
					* 在子类中找，有就使用
					* 在父类中找，有就使用
					* 找不到，就报错
	+ 两个面试题：
		- Override（覆盖）和Overload（重载）的区别?
		    - 方法重写：
			   * 在子类中，出现和父类中一模一样的方法声明的现象。
		    - 方法重载：
	         * 同一个类中，出现的方法名相同，参数列表不同的现象。
		    - Overload是否可以改变返回值类型?
			   *  方法重载能改变返回值类型，因为它和返回值类型无关。 
		   - this和super的区别和各自的作用?
		     + this:代表当前类的对象引用
		     + super:代表父类存储空间的标识。(可以理解为父类的引用，通过这个东西可以访问父类的成员)
	- 数据初始化的面试题
		- 一个类的初始化过程
		  + 成员变量的初始化
		  + 默认初始化
		  + 显示初始化
		  + 构造方法初始化
		- 子父类的构造执行过程(分层初始化)
	     + 先进行父类初始化，然后进行子类初始化。
	
##Day9 
1. final关键字(掌握)
  + 是最终的意思，可以修饰类，方法，变量。
  + 特点：
	 - 它修饰的类，不能被继承。
	 - 它修饰的方法，不能被重写。
	 - 它修饰的变量，是一个常量。
  + 面试相关：
	 - 局部变量
		 * 基本类型 值不能发生改变
		 * 引用类型 地址值不能发生改变，但是对象的内容是可以改变的
	 - 初始化时机
		 * 只能初始化一次。
		 * 常见的给值
			 - 定义的时候。(推荐)
			 - 构造方法中。
	
2. 多态(掌握)
 + 同一个对象在不同时刻体现出来的不同状态。
 + 多态的前提：
	 - 有继承或者实现关系。
	 - 有方法重写。
	 - 有父类或者父接口引用指向子类对象。

 + 多态的分类：
	  - 具体类多态
		  
		```Java
	   class Fu {}
	   class Zi extends Fu {}
	   
		Fu f = new Zi();
		```
		
     - 抽象类多态
		 
		```Java
	   abstract class Fu {}
		class Zi extends Fu {}
		
		Fu f = new Zi();
		```
	  - 接口多态
	
		```Java
		interface Fu {}
		class Zi implements Fu {}
		
		Fu f = new Zi();
		```
		   - 多态中的成员访问特点 
	 
			 - 成员变量
				 * 编译看左边，运行看左边
			 - 构造方法
				 * 子类的构造都会默认访问父类构造
			 - 成员方法
				 * 编译看左边，运行看右边
			 - 静态方法
				 * 编译看左边，运行看左边 
			 - 为什么?
				 * 因为成员方法有重写。

3. 抽象类
	- 抽象类的成员特点：
		+ 成员变量
			- 有变量，有常量
		
		+ 构造方法
			- 有构造方法
		
		+ 成员方法
			- 有抽象，有非抽象
	- 抽象类的几个小问题
		
		+ 抽象类有构造方法，不能实例化，那么构造方法有什么用?
			* 用于子类访问父类数据的初始化
		
		+ 一个类如果没有抽象方法,却定义为了抽象类，有什么用?
			* 为了不让创建对象
		
		+ abstract不能和哪些关键字共存
			- final	冲突
			- private 冲突
			- static 无意义

4. 接口(更加抽象的抽象类)
	+ 接口的特点：
		- 接口用关键字interface修饰
			* interface 接口名 {}
		- 类实现接口用implements修饰
			* class 类名 implements 接口名 {}
	
	+ 接口的成员特点：
		- 成员变量
			* 只能是常量
			* 默认修饰符：public static final
		- 构造方法
			* 没有构造方法
		- 成员方法
			* 只能是抽象的
			* 默认修饰符：public abstract
	
	+ 抽象类和接口的区别?
		- 抽象类：is a，抽象类中定义的是共性功能。
		- 接口：like a，接口中定义的是扩展功能。

##Day10

