# <center>JAVA SE 基础总结（7-14）
##Day7
1. 成员变量和局部变量的区别
	- 在类中的位置不同
		+ 成员变量：类中方法外
		+ 局部变量：方法定义中或者方法声明上
	- 在内存中的位置不同
		+ 成员变量：在堆中
		+ 局部变量：在栈中
	- 生命周期不同
		+ 成员变量：随着对象的创建而存在，随着对象的消失而消失
		+ 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失
	- 初始化值不同
		+ 成员变量：有默认值
		+ 局部变量：没有默认值，必须定义，赋值，然后才能使用
2. 匿名对象
	- 没有名字的对象
	- 应用场景
		+ 调用方法，仅仅只调用一次的时候。
		+ 可以作为实际参数传递。
		
3. 封装
	+ 隐藏实现细节，提供公共的访问方式
	+ 好处：
		- 隐藏实现细节，提供公共的访问方式
		- 提高代码的复用性
		- 提高代码的安全性
	+ 设计原则
		- 把不想让外界知道的实现细节给隐藏起来，提供公共的访问方式
	+ private是封装的一种体现。
		- 封装：类，方法，private修饰成员变量

4. 构造方法
	+ 构造方法中可不可以有return语句呢?
		- 可以。而是我们写成这个样子就OK了：return;
		- 其实，在任何的void类型的方法的最后你都可以写上：return;
	+ 推荐：永远手动自己给出无参构造方法。

5. static关键字
	+ 静态的意思。可以修饰成员变量和成员方法。
	+ 静态的特点：
		- 随着类的加载而加载
		- 优先与对象存在
		- 被类的所有对象共享
			* 这其实也是我们判断该不该使用静态的依据。
			* 举例：饮水机和水杯的问题思考
		- 可以通过类名调用
			* 既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。
	+ 静态的内存图
		- 静态的内容在方法区的静态区
	+ 静态的注意事项；
		- 在静态方法中没有this对象
		- 静态只能访问静态(代码测试过)
	+ 静态变量和成员变量的区别
		- 所属不同
			* 静态变量：属于类，类变量
			* 成员变量：属于对象，对象变量，实例变量
		- 内存位置不同
			* 静态变量：方法区的静态区
			* 成员变量：堆内存
		- 生命周期不同
			* 静态变量：静态变量是随着类的加载而加载，随着类的消失而消失
			* 成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失
		- 调用不同
			* 静态变量：可以通过对象名调用，也可以通过类名调用(非私有)
			* 成员变量：只能通过对象名调用(非私有)

##Day8
1. 如何制作帮助文档(了解)
	+ 写一个类
	+ 加入文档注释
	+ 通过javadoc工具生成即可
		 `javadoc -d 目录 -author -version ArrayTool.java`
2. Math类
	+ 是针对数学进行操作的类
	+ 没有构造方法，因为它的成员都是静态的
	+ 产生随机数
      `public static double random(): [0.0,1.0)`
	+ 如何产生一个1-100之间的随机数
		`int number = (int)(Math.random()*100)+1;`

3. 代码块
	+ 用{}括起来的代码。
	+ 分类：
		- 局部代码块
			* 用于限定变量的生命周期，及早释放，提高内存利用率。
		- 构造代码块
			* 把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。
		- 静态代码块
			* 对类的数据进行初始化，仅仅只执行一次。
	+ 静态代码块,构造代码块,构造方法的顺序问题?
		- 静态代码块 > 构造代码块 > 构造方法
	
	```Java
	/*
	代码块：在Java中，使用{}括起来的代码被称为代码块。
	根据其位置和声明的不同，可以分为
		>局部代码块:局部位置,用于限定变量的生命周期。
		>构造代码块:在类中的成员位置,用{}括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。
			作用：可以把多个构造方法中的共同代码放到一起，对对象进行初始化。
		静态代码块:在类中的成员位置,用{}括起来的代码,只不过它用static修饰了。
			作用：一般是对类进行初始化。
	面试题?
		静态代码块,构造代码块,构造方法的执行顺序?
		静态代码块 -- 构造代码块 -- 构造方法
		静态代码块：只执行一次
		构造代码块：每次调用构造方法都执行
*/
class Student {
	static {
		System.out.println("Student 静态代码块");
	}
	
	{
		System.out.println("Student 构造代码块");
	}
	
	public Student() {
		System.out.println("Student 构造方法");
	}
}
	//测试
	class StudentDemo {
	static {
		System.out.println("林青霞都60了，我很伤心");
	}
	
	public static void main(String[] args) {
		System.out.println("我是main方法");
		
		Student s1 = new Student();
		Student s2 = new Student();
		
	程序的执行结果：
	林青霞都60了，我很伤心
	我是main方法
	Student 静态代码块（只执行一次）
	Student 构造代码块（调用一次，执行一次）
	Student 构造方法（调用一次，执行一次）
	Student 构造代码块（只执行一次）
	Student 构造方法（调用一次，执行一次）
	}
	```
	
4. 继承
	+ Java中继承的特点
		 - Java中类只支持单继承
		 - Java中可以多层(重)继承(继承体系)
	+ 继承的注意事项：
		- 子类不能继承父类的私有成员
		- 子类不能继承父类的构造方法，但是可以通过super去访问
		- 不要为了部分功能而去继承
	+ 什么时候使用继承呢?
		- 继承体现的是：is a的关系。
		- 采用假设法
	+ Java继承中的成员关系
		- 子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?
			* 在子类方法的局部范围找，有就使用。
			* 在子类的成员范围找，有就使用。
			* 在父类的成员范围找，有就使用。
			* 找不到，就报错。
		- 构造方法
			* 子类的构造方法默认会去访问父类的无参构造方法
			  - 是为了子类访问父类数据的初始化
			  - 父类中如果没有无参构造方法，怎么办?
			  - 子类通过super去明确调用带参构造
			  - 子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造
				让父类提供无参构造
		- 成员方法
			+ 子类的成员方法和父类中的成员方法名称不一样，这个太简单
			+ 子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?
				- 通过子类对象访y问一个方法的查找顺序：
					* 在子类中找，有就使用
					* 在父类中找，有就使用
					* 找不到，就报错
	+ 两个面试题：
		- Override（覆盖）和Overload（重载）的区别?
		    - 方法重写：
			   * 在子类中，出现和父类中一模一样的方法声明的现象。
		    - 方法重载：
	         * 同一个类中，出现的方法名相同，参数列表不同的现象。
		    - Overload是否可以改变返回值类型?
			   *  方法重载能改变返回值类型，因为它和返回值类型无关。 
		   - this和super的区别和各自的作用?
		     + this:代表当前类的对象引用
		     + super:代表父类存储空间的标识。(可以理解为父类的引用，通过这个东西可以访问父类的成员)
	- 数据初始化的面试题
		- 一个类的初始化过程
		  + 成员变量的初始化
		  + 默认初始化
		  + 显示初始化
		  + 构造方法初始化
		- 子父类的构造执行过程(分层初始化)
	     + 先进行父类初始化，然后进行子类初始化。
	
##Day9 
1. final关键字(掌握)
  + 是最终的意思，可以修饰类，方法，变量。
  + 特点：
	 - 它修饰的类，不能被继承。
	 - 它修饰的方法，不能被重写。
	 - 它修饰的变量，是一个常量。
  + 面试相关：
	 - 局部变量
		 * 基本类型 值不能发生改变
		 * 引用类型 地址值不能发生改变，但是对象的内容是可以改变的
	 - 初始化时机
		 * 只能初始化一次。
		 * 常见的给值
			 - 定义的时候。(推荐)
			 - 构造方法中。
	
2. 多态(掌握)
 + 同一个对象在不同时刻体现出来的不同状态。
 + 多态的前提：
	 - 有继承或者实现关系。
	 - 有方法重写。
	 - 有父类或者父接口引用指向子类对象。

 + 多态的分类：
	  - 具体类多态
		  
		```Java
	   class Fu {}
	   class Zi extends Fu {}
	   
		Fu f = new Zi();
		```
		
     - 抽象类多态
		 
		```Java
	   abstract class Fu {}
		class Zi extends Fu {}
		
		Fu f = new Zi();
		```
	  - 接口多态
	
		```Java
		interface Fu {}
		class Zi implements Fu {}
		
		Fu f = new Zi();
		```
		   - 多态中的成员访问特点 
	 
			 - 成员变量
				 * 编译看左边，运行看左边
			 - 构造方法
				 * 子类的构造都会默认访问父类构造
			 - 成员方法
				 * 编译看左边，运行看右边
			 - 静态方法
				 * 编译看左边，运行看左边 
			 - 为什么?
				 * 因为成员方法有重写。

3. 抽象类
	- 抽象类的成员特点：
		+ 成员变量
			- 有变量，有常量
		
		+ 构造方法
			- 有构造方法
		
		+ 成员方法
			- 有抽象，有非抽象
	- 抽象类的几个小问题
		
		+ 抽象类有构造方法，不能实例化，那么构造方法有什么用?
			* 用于子类访问父类数据的初始化
		
		+ 一个类如果没有抽象方法,却定义为了抽象类，有什么用?
			* 为了不让创建对象
		
		+ abstract不能和哪些关键字共存
			- final	冲突
			- private 冲突
			- static 无意义

4. 接口(更加抽象的抽象类)
	+ 接口的特点：
		- 接口用关键字interface修饰
			* interface 接口名 {}
		- 类实现接口用implements修饰
			* class 类名 implements 接口名 {}
	
	+ 接口的成员特点：
		- 成员变量
			* 只能是常量
			* 默认修饰符：public static final
		- 构造方法
			* 没有构造方法
		- 成员方法
			* 只能是抽象的
			* 默认修饰符：public abstract
	
	+ 抽象类和接口的区别?
		- 抽象类：is a，抽象类中定义的是共性功能。
		- 接口：like a，接口中定义的是扩展功能。

##Day10
1. 包(理解)
	- 带包的编译和运行 
		+ 手动式
		+ 自动式(掌握)
			`javac -d . HelloWorld.java`
	
	- package,import,class的顺序
		`package > import > class`

2. 内部类(理解)
	+ 把类定义在另一个类的内部，该类就被称为内部类。
	+ 内部类的访问规则
		- 可以直接访问外部类的成员，包括私有
		- 外部类要想访问内部类成员，必须创建对象
		 
	+ 内部类的分类
		- 成员内部类 
		- 局部内部类
	+ 成员内部类
		- private 为了数据的安全性
		- static 为了访问的方便性	
		
		```java
		成员内部类不是静态的：
			外部类名.内部类名 对象名 = new 外部类名.new 内部类名();
		成员内部类是静态的：
			外部类名.内部类名 对象名 = new 外部类名.内部类名();
		```
	+ 成员内部类的面试题(填空)
		
		``` 
		30,20,10
		
		class Outer {
			public int num = 10;
			
			class Inner {
				public int num = 20;
				
				public viod show() {
					int num  = 30;
					
					System.out.println(num);
					System.out.println(this.num);
					System.out.println(Outer.this.num);
				}
			}
		}
	```
	+ 局部内部类
		- 局部内部类访问局部变量必须加final修饰。
		- 为什么呢?
			因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。
			所以，堆内存还是用该变量，而改变量已经没有了。
			为了让该值还存在，就加final修饰。
			通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。
	+ 匿名内部类(掌握)
		- 是局部内部类的简化形式
	   - 格式:
	    
	   	```
			new 类名或者接口名() {
				重写方法;
			}
			```

	+ 匿名内部类的面试题(补齐代码)
		
		```
		interface Inter {
			void show();
		}
		
		class Outer {
			//补齐代码
			public static Inter method() {
				return new Inter() {
					public void show() {
						System.out.println("HelloWorld");
					}	
				};
			}
		}
		
		class OuterDemo {
			public static void main(String[] args) {
				Outer.method().show(); //"HelloWorld"
			}
		}
	```
	
##Day11 
1. Object类(掌握)
	+ Object类的构造方法有一个，并且是无参构造
	+ 要掌握的方法：
	  	
	  	```
		toString()
			返回对象的字符串表示，默认是由类的全路径+'@'+哈希值的十六进制表示。
			这个表示其实是没有意义的，一般子类都会重写该方法。
			如何重写呢?过程我也讲解过了，基本上就是要求信息简单明了。
			但是最终还是自动生成。
		equals()
			比较两个对象是否相同。默认情况下，比较的是地址值是否相同。
			而比较地址值是没有意义的，所以，一般子类也会重写该方法。
			重写过程，我也详细的讲解和分析了。
			但是最终还是自动生成。
		```
	
	+ 要了解的方法
	  
	  ```
		A:hashCode() 返回对象的哈希值。不是实际地址值，可以理解为地址值。
		B:getClass() 返回对象的字节码文件对象，反射中我们会详细讲解	
		C:finalize() 用于垃圾回收，在不确定的时间
		D:clone() 可以实现对象的克隆，包括成员变量的数据复制，但是它和两个引用指向同一个对象是有区别的。
    ```
```
	==和equals()的区别?
	A:==
	基本类型：比较的是值是否相同
	引用类型：比较的是地址值是否相同
	B:equals()
	只能比较引用类型。默认情况下，比较的是地址值是否相同。
	但是，我们可以根据自己的需要重写该方法。
```

##Day12
1. Scanner类
2. String类

##Day13
1. StringBuffer(掌握)
	+ 用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了一个字符串缓冲区类。StringBuffer供我们使用。
	
	+ StringBuffer的构造方法
		A:StringBuffer()
		B:StringBuffer(int size)
		C:StringBuffer(String str)
		
	+ 小细节：
		* StringBuffer：同步的，数据安全，效率低。
		* StringBuilder：不同步的，数据不安全，效率高。
		* String,StringBuffer,StringBuilder的区别
			- String 字符串常量
			- StringBuffer 字符串变量（线程安全）
			- StringBuilder 字符串变量（非线程安全）
		* StringBuffer和数组的区别?
	
2. Integer(掌握)

	+ String和int的相互转换
		* String -- int
			- Integer.parseInt("100");
		* int -- String
			- String.valueOf(100);

	+ 面试题
	 
		- -128到127之间的数据缓冲池问题
			- Integer的数据直接赋值，如果在-128到127之间，会直接从缓冲池里获取数据

3. Character(了解)
	
	+ Character构造方法	
		* Character ch = new Character('a');
	
	+ 要掌握的方法：(自己补齐)
		* 判断给定的字符是否是大写
		* 判断给定的字符是否是小写
		* 判断给定的字符是否是数字字符
		* 把给定的字符转成大写
		* 把给定的字符转成小写

##Day14
1. 正则表达式(理解)
	+ 就是符合一定规则的字符串
	+ 常见规则
		- 字符
	      
	      ``` 
			x 字符 x。举例：'a'表示字符a
			\\ 反斜线字符。
			\n 新行（换行）符 ('\u000A') 
			\r 回车符 ('\u000D')
			```
		- 字符类
		   
		   ```
			[abc] a、b 或 c（简单类） 
			[^abc] 任何字符，除了 a、b 或 c（否定） 
			[a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） 
			[0-9] 0到9的字符都包括
			```
		- 预定义字符类
		   
		   ``` 
			. 任何字符。我的就是.字符本身，怎么表示呢? \.
			\d 数字：[0-9]
			\w 单词字符：[a-zA-Z_0-9]
				在正则表达式里面组成单词的东西必须有这些东西组成
         ```
		- 边界匹配器
		   
		   ``` 
			^ 行的开头 
			$ 行的结尾 
			\b 单词边界
				就是不是单词字符的地方。
				举例：hello world?haha;xixi
			```
		- Greedy 数量词 
		   
		   ``` 
			X? X，一次或一次也没有
			X* X，零次或多次
			X+ X，一次或多次
			X{n} X，恰好 n 次 
			X{n,} X，至少 n 次 
			X{n,m} X，至少 n 次，但是不超过 m 次 
			```
	+ 常见功能：(分别用的是谁呢?)
		- 判断功能
			* String类的public boolean matches(String regex)
		- 分割功能
			* String类的public String[] split(String regex)
		- 替换功能
			* String类的public String replaceAll(String regex,String replacement)
		- 获取功能
			 * Pattern和Matcher
			 *	Pattern p = Pattern.compile("a*b");
			 *	Matcher m = p.matcher("aaaaab");
2. Math
 
3. Random(理解)
	+ 构造方法:
		- Random() 默认种子，每次产生的随机数不同
		- Random(long seed) 指定种子，每次种子相同，随机数就相同
	+ 成员方法:
		+ int nextInt() 返回int范围内的随机数
		+ int nextInt(int n) 返回[0,n)范围内的随机数

4. System(掌握)


5. BigInteger(理解)
	+ 针对大整数的运算
	+ 构造方法	
		- BigInteger(String s)

6. BigDecimal(理解)
	+ 浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。(金融相关的项目)
	+ 构造方法
		- BigDecimal(String s)

7. Date/DateFormat(掌握)
	+ Date是日期类，可以精确到毫秒。
		- 构造方法
			* Date()
			* Date(long time)
		- 成员方法
			* getTime()
			* setTime(long time)
	+ DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat
		+ SimpleDateFormat(String pattern) 给定模式
			- yyyy-MM-dd HH:mm:ss
		+ 日期和字符串的转换
			- Date -- String
				format()
				
		   - String -- Date
				parse()

8. Calendar(掌握)
	+ 日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。
	+ 如何得到一个日历对象呢?
		Calendar rightNow = Calendar.getInstance();
	+ 成员方法
		- 根据日历字段得到对应的值
		- 根据日历字段和一个正负数确定是添加还是减去对应日历字段的值
		- 设置日历对象的年月日

